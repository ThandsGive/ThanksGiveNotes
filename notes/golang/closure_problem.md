# 闭包问题

喜大普奔的好消息，Go 1.22 发布了，而基于发布的说明以及官网博客中可知，第一个值得注意的点便是解决了 golang 中长期存在的 for 循环陷阱，即在迭代之间意外共享循环变量，也就是我们常说的 [闭包问题]

[详情请看官网博文 - Go 1.22 is released!](https://go.dev/blog/go1.22)

而这个便利，如果是单单用于我们学习的话，那的确是可以很直接的进行使用的。但如果是生产环境，那么可能就不是那么容易了，毕竟升级一个线上环境的语言版本，对于需要承当的代价有时是无法估量的。所以这就引出了本文的重心了，接着这个时机，让我们重新梳理一下，什么是 golang 的循环陷阱 - [闭包问题]

首先我们先切换一下我们的 golang 版本，任意[低于 1.22 的版本都存在这个问题]，本文使用的是 go1.20.6  

我们先来看一个错误示范的代码案例(我相信你一定也写过相似的 😉 )

```go
func ClosureProblem() {
	funcs := make([]func(), 0)
	for i := 0; i < 3; i++ {
        // fmt.Println(&i, " <------> ", i)
		funcs = append(funcs, func() { fmt.Println(i) })
	}
	for _, f := range funcs {
		f() // 来来来，说出你内心的想法吧！1, 2, 3 是不是？to run 一下吧
	}
}
/*
不出意料的话，结果应该是如下: 
3
3
3
*/
```
而运行后的结果显然是和我们的预想差距很大，不说是完全一样，只能说是南辕北辙了。  
而原因的根本便是，[闭包捕获的是变量的引用，而不是值。加之在for循环中，始终是对 <同一个变量> 反复进行赋值引用]，如此在循环结束时，i 引用的最终值是 3 ，所以所有的闭包在执行时都会打印 3

我们在上述函数中，让我们放开 for 中的注释代码来验证一下结论: [for循环中，始终是对 <同一个变量> 反复进行赋值引用]
```go
// fmt.Println(&i, " <------> ", i)
/* 
结果如下: 
0xc0002709f8  <------>  0
0xc0002709f8  <------>  1
0xc0002709f8  <------>  2
*/
```
如此我们可以总结一下闭包问题的结论了  
* 1、闭包中捕获的是变量的引用；
* 2、for循环中是对同一个变量进行反复赋值引用；

而除了升级到 Go 1.22 版本外，我们在当下版本上的解决方案呢？主要有两个方法，如下：  
* 1、局部变量替代法
```go
// 通过 局部变量解决闭包
func LocalValueToDealClosure() {
	funcs := make([]func(), 0)
	for i := 0; i < 3; i++ {
		j := i
		funcs = append(funcs, func() { fmt.Println(&j, " <------> ", j) })
	}
	for _, f := range funcs {
		f()
	}
}
/* 
0xc0002709f8  <------>  0
0xc000270a00  <------>  1
0xc000270a08  <------>  2
*/
```
* 2、传递参数替代法
```go
// 通过 传递参数解决闭包
func PassParamsToDealClosure() {
	funcs := make([]func(), 0)
	for i := 0; i < 3; i++ {
		funcs = append(funcs, func(n int) func() {
			return func() { fmt.Println(&n, " <------> ", n) }
		}(i))
	}
	for _, f := range funcs {
		f()
	}
}
/* 
0xc000292968  <------>  0
0xc000292970  <------>  1
0xc000292978  <------>  2
*/
```
---
如此，我们也得到了在现有版本下解决闭包问题的方法。上述的局部参数替代法 和 函数传参法，其实从根本上来说都是 将 循环中的全局引用转化为了局部引用。这里第一个局部替代法比较直观，而第二个方法的函数传参就引用了 golang 的另一个概念: [ [Go 的函数传参都是 值拷贝](function_params_passing.md) ]